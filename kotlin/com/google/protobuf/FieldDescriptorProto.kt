// Code generated by Wire protocol buffer compiler, do not edit.
// Source file: google/protobuf/descriptor.proto
package com.google.protobuf

import com.squareup.wire.EnumAdapter
import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.TagHandler
import com.squareup.wire.WireEnum
import com.squareup.wire.WireField
import kotlin.Deprecated
import kotlin.DeprecationLevel
import kotlin.Int
import kotlin.String
import kotlin.jvm.JvmField
import kotlin.jvm.JvmStatic
import okio.ByteString

/**
 * Describes a field within a message.
 */
data class FieldDescriptorProto(
  @field:WireField(tag = 1, adapter = "com.squareup.wire.ProtoAdapter#STRING") val name: String? =
      null,
  @field:WireField(tag = 3, adapter = "com.squareup.wire.ProtoAdapter#INT32") val number: Int? =
      null,
  @field:WireField(tag = 4, adapter = "com.google.protobuf.FieldDescriptorProto.Label#ADAPTER")
      val label: Label? = null,
  /**
   * If type_name is set, this need not be set.  If both this and type_name
   * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
   */
  @field:WireField(tag = 5, adapter = "com.google.protobuf.FieldDescriptorProto.Type#ADAPTER")
      val type: Type? = null,
  /**
   * For message and enum types, this is the name of the type.  If the name
   * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
   * rules are used to find the type (i.e. first the nested types within this
   * message are searched, then within the parent, on up to the root
   * namespace).
   */
  @field:WireField(tag = 6, adapter = "com.squareup.wire.ProtoAdapter#STRING") val type_name:
      String? = null,
  /**
   * For extensions, this is the name of the type being extended.  It is
   * resolved in the same manner as type_name.
   */
  @field:WireField(tag = 2, adapter = "com.squareup.wire.ProtoAdapter#STRING") val extendee: String?
      = null,
  /**
   * For numeric types, contains the original text representation of the value.
   * For booleans, "true" or "false".
   * For strings, contains the default text contents (not escaped in any way).
   * For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
   * TODO(kenton):  Base-64 encode?
   */
  @field:WireField(tag = 7, adapter = "com.squareup.wire.ProtoAdapter#STRING") val default_value:
      String? = null,
  /**
   * If set, gives the index of a oneof in the containing type's oneof_decl
   * list.  This field is a member of that oneof.
   */
  @field:WireField(tag = 9, adapter = "com.squareup.wire.ProtoAdapter#INT32") val oneof_index: Int?
      = null,
  /**
   * JSON name of this field. The value is set by protocol compiler. If the
   * user has set a "json_name" option on this field, that option's value
   * will be used. Otherwise, it's deduced from the field's name by converting
   * it to camelCase.
   */
  @field:WireField(tag = 10, adapter = "com.squareup.wire.ProtoAdapter#STRING") val json_name:
      String? = null,
  @field:WireField(tag = 8, adapter = "com.google.protobuf.FieldOptions#ADAPTER") val options:
      FieldOptions? = null,
  val unknownFields: ByteString = ByteString.EMPTY
) : Message<FieldDescriptorProto, FieldDescriptorProto.Builder>(ADAPTER, unknownFields) {
  @Deprecated(
      message = "Shouldn't be used in Kotlin",
      level = DeprecationLevel.HIDDEN
  )
  override fun newBuilder(): Builder = Builder(this.copy())

  class Builder(private val message: FieldDescriptorProto) : Message.Builder<FieldDescriptorProto,
      Builder>() {
    override fun build(): FieldDescriptorProto = message
  }

  companion object {
    @JvmField
    val ADAPTER: ProtoAdapter<FieldDescriptorProto> = object : ProtoAdapter<FieldDescriptorProto>(
      FieldEncoding.LENGTH_DELIMITED, 
      FieldDescriptorProto::class.java
    ) {
      override fun encodedSize(value: FieldDescriptorProto): Int = 
        ProtoAdapter.STRING.encodedSizeWithTag(1, value.name) +
        ProtoAdapter.INT32.encodedSizeWithTag(3, value.number) +
        Label.ADAPTER.encodedSizeWithTag(4, value.label) +
        Type.ADAPTER.encodedSizeWithTag(5, value.type) +
        ProtoAdapter.STRING.encodedSizeWithTag(6, value.type_name) +
        ProtoAdapter.STRING.encodedSizeWithTag(2, value.extendee) +
        ProtoAdapter.STRING.encodedSizeWithTag(7, value.default_value) +
        ProtoAdapter.INT32.encodedSizeWithTag(9, value.oneof_index) +
        ProtoAdapter.STRING.encodedSizeWithTag(10, value.json_name) +
        FieldOptions.ADAPTER.encodedSizeWithTag(8, value.options) +
        value.unknownFields.size

      override fun encode(writer: ProtoWriter, value: FieldDescriptorProto) {
        ProtoAdapter.STRING.encodeWithTag(writer, 1, value.name)
        ProtoAdapter.INT32.encodeWithTag(writer, 3, value.number)
        Label.ADAPTER.encodeWithTag(writer, 4, value.label)
        Type.ADAPTER.encodeWithTag(writer, 5, value.type)
        ProtoAdapter.STRING.encodeWithTag(writer, 6, value.type_name)
        ProtoAdapter.STRING.encodeWithTag(writer, 2, value.extendee)
        ProtoAdapter.STRING.encodeWithTag(writer, 7, value.default_value)
        ProtoAdapter.INT32.encodeWithTag(writer, 9, value.oneof_index)
        ProtoAdapter.STRING.encodeWithTag(writer, 10, value.json_name)
        FieldOptions.ADAPTER.encodeWithTag(writer, 8, value.options)
        writer.writeBytes(value.unknownFields)
      }

      override fun decode(reader: ProtoReader): FieldDescriptorProto {
        var name: String? = null
        var number: Int? = null
        var label: Label? = null
        var type: Type? = null
        var type_name: String? = null
        var extendee: String? = null
        var default_value: String? = null
        var oneof_index: Int? = null
        var json_name: String? = null
        var options: FieldOptions? = null
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> name = ProtoAdapter.STRING.decode(reader)
            3 -> number = ProtoAdapter.INT32.decode(reader)
            4 -> label = Label.ADAPTER.decode(reader)
            5 -> type = Type.ADAPTER.decode(reader)
            6 -> type_name = ProtoAdapter.STRING.decode(reader)
            2 -> extendee = ProtoAdapter.STRING.decode(reader)
            7 -> default_value = ProtoAdapter.STRING.decode(reader)
            9 -> oneof_index = ProtoAdapter.INT32.decode(reader)
            10 -> json_name = ProtoAdapter.STRING.decode(reader)
            8 -> options = FieldOptions.ADAPTER.decode(reader)
            else -> TagHandler.UNKNOWN_TAG
          }
        }
        return FieldDescriptorProto(
          name = name,
          number = number,
          label = label,
          type = type,
          type_name = type_name,
          extendee = extendee,
          default_value = default_value,
          oneof_index = oneof_index,
          json_name = json_name,
          options = options,
          unknownFields = unknownFields
        )
      }

      override fun redact(value: FieldDescriptorProto): FieldDescriptorProto? = value.copy(
        options = value.options?.let(FieldOptions.ADAPTER::redact),
        unknownFields = ByteString.EMPTY
      )
    }
  }

  enum class Type(private val value: Int) : WireEnum {
    /**
     * 0 is reserved for errors.
     * Order is weird for historical reasons.
     */
    TYPE_DOUBLE(1),

    TYPE_FLOAT(2),

    /**
     * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
     * negative values are likely.
     */
    TYPE_INT64(3),

    TYPE_UINT64(4),

    /**
     * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
     * negative values are likely.
     */
    TYPE_INT32(5),

    TYPE_FIXED64(6),

    TYPE_FIXED32(7),

    TYPE_BOOL(8),

    TYPE_STRING(9),

    /**
     * Tag-delimited aggregate.
     * Group type is deprecated and not supported in proto3. However, Proto3
     * implementations should still be able to parse the group wire format and
     * treat group fields as unknown fields.
     */
    TYPE_GROUP(10),

    /**
     * Length-delimited aggregate.
     */
    TYPE_MESSAGE(11),

    /**
     * New in version 2.
     */
    TYPE_BYTES(12),

    TYPE_UINT32(13),

    TYPE_ENUM(14),

    TYPE_SFIXED32(15),

    TYPE_SFIXED64(16),

    /**
     * Uses ZigZag encoding.
     */
    TYPE_SINT32(17),

    /**
     * Uses ZigZag encoding.
     */
    TYPE_SINT64(18);

    override fun getValue(): Int = value

    companion object {
      @JvmField
      val ADAPTER: ProtoAdapter<Type> = object : EnumAdapter<Type>(
        Type::class.java
      ) {
        override fun fromValue(value: Int): Type = Type.fromValue(value)
      }

      @JvmStatic
      fun fromValue(value: Int): Type = when (value) {
        1 -> TYPE_DOUBLE
        2 -> TYPE_FLOAT
        3 -> TYPE_INT64
        4 -> TYPE_UINT64
        5 -> TYPE_INT32
        6 -> TYPE_FIXED64
        7 -> TYPE_FIXED32
        8 -> TYPE_BOOL
        9 -> TYPE_STRING
        10 -> TYPE_GROUP
        11 -> TYPE_MESSAGE
        12 -> TYPE_BYTES
        13 -> TYPE_UINT32
        14 -> TYPE_ENUM
        15 -> TYPE_SFIXED32
        16 -> TYPE_SFIXED64
        17 -> TYPE_SINT32
        18 -> TYPE_SINT64
        else -> throw IllegalArgumentException("""Unexpected value: $value""")
      }
    }
  }

  enum class Label(private val value: Int) : WireEnum {
    /**
     * 0 is reserved for errors
     */
    LABEL_OPTIONAL(1),

    LABEL_REQUIRED(2),

    LABEL_REPEATED(3);

    override fun getValue(): Int = value

    companion object {
      @JvmField
      val ADAPTER: ProtoAdapter<Label> = object : EnumAdapter<Label>(
        Label::class.java
      ) {
        override fun fromValue(value: Int): Label = Label.fromValue(value)
      }

      @JvmStatic
      fun fromValue(value: Int): Label = when (value) {
        1 -> LABEL_OPTIONAL
        2 -> LABEL_REQUIRED
        3 -> LABEL_REPEATED
        else -> throw IllegalArgumentException("""Unexpected value: $value""")
      }
    }
  }
}
